// -*- C++ -*-
//===------------------------------- simd ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
#ifndef _LIBCPP_EXPERIMENTAL_SIMD
#define _LIBCPP_EXPERIMENTAL_SIMD

#define __cpp_lib_experimental_parallel_simd 201803

/*
    experimental/simd synopsis

namespace std::experimental {

inline namespace parallelism_v2 {

namespace simd_abi {

struct scalar {};
template <int N> struct fixed_size {};
template <typename T> inline constexpr int max_fixed_size = implementation-defined;
template <typename T> using compatible = implementation-defined;
template <typename T> using native = implementation-defined;

template <class T, size_t N, class... Abis> struct deduce { using type = see below; };
template <class T, size_t N, class... Abis> using deduce_t =
  typename deduce<T, N>::type;

} // simd_abi

struct element_aligned_tag {};
struct vector_aligned_tag {};
template <size_t> struct overaligned_tag {};
inline constexpr element_aligned_tag element_aligned{};
inline constexpr vector_aligned_tag vector_aligned{};
template <size_t N> inline constexpr overaligned_tag<N> overaligned{};

// 9.4, simd type traits
template <class T> struct is_abi_tag;
template <class T> inline constexpr bool is_abi_tag_v = is_abi_tag<T>::value;

template <class T> struct is_simd;
template <class T> inline constexpr bool is_simd_v = is_simd<T>::value;

template <class T> struct is_simd_mask;
template <class T> inline constexpr bool is_simd_mask_v = is_simd_mask<T>::value;

template <class T> struct is_simd_flag_type;
template <class T> inline constexpr bool is_simd_flag_type_v =
  is_simd_flag_type<T>::value;

template <class T, class Abi = simd_abi::compatible<T>> struct simd_size;
template <class T, class Abi = simd_abi::compatible<T>>
  inline constexpr size_t simd_size_v = simd_size<T, Abi>::value;

template <class T, class U = typename T::value_type> struct memory_alignment;
template <class T, class U = typename T::value_type>
  inline constexpr size_t memory_alignment_v = memory_alignment<T, U>::value;

template<class T, class V> struct rebind_simd { using type = see below; };
template<class T, class V> using rebind_simd_t = typename rebind_simd<T, V>::type;
template<int N, class V> struct resize_simd { using type = see below; };
template<int N, class V> using resize_simd_t = typename resize_simd<N, V>::type;

// 9.6, Class template simd
template <class T, class Abi = simd_abi::compatible<T>> class simd;
template <class T> using native_simd = simd<T, simd_abi::native<T>>;
template <class T, int N> using fixed_size_simd = simd<T, simd_abi::fixed_size<N>>;

// 9.8, Class template simd_mask
template <class T, class Abi = simd_abi::compatible<T>> class simd_mask;
template <class T> using native_simd_mask = simd_mask<T, simd_abi::native<T>>;
template <class T, int N> using fixed_size_simd_mask =
  simd_mask<T, simd_abi::fixed_size<N>>;

// 9.7.5, Casts
template <class T, class U, class Abi> see below simd_cast(const simd<U, Abi>&) noexcept;
template <class T, class U, class Abi> see below static_simd_cast(const simd<U, Abi>&) noexcept;

template <class T, class Abi>
  fixed_size_simd<T, simd_size_v<T, Abi>>
    to_fixed_size(const simd<T, Abi>&) noexcept;
template <class T, class Abi>
  fixed_size_simd_mask<T, simd_size_v<T, Abi>>
    to_fixed_size(const simd_mask<T, Abi>&) noexcept;
template <class T, size_t N>
  native_simd<T> to_native(const fixed_size_simd<T, N>&) noexcept;
template <class T, size_t N>
  native_simd_mask<T> to_native(const fixed_size_simd_mask<T, N>> &) noexcept;
template <class T, size_t N>
  simd<T> to_compatible(const fixed_size_simd<T, N>&) noexcept;
template <class T, size_t N>
  simd_mask<T> to_compatible(const fixed_size_simd_mask<T, N>&) noexcept;

template <size_t... Sizes, class T, class Abi>
  tuple<simd<T, simd_abi::deduce_t<T, Sizes>>...>
    split(const simd<T, Abi>&);
template <size_t... Sizes, class T, class Abi>
  tuple<simd_mask<T, simd_mask_abi::deduce_t<T, Sizes>>...>
    split(const simd_mask<T, Abi>&);
template <class V, class Abi>
  array<V, simd_size_v<typename V::value_type, Abi> / V::size()>
    split(const simd<typename V::value_type, Abi>&) noexcept;
template <class V, class Abi>
  array<V, simd_size_v<typename V::value_type, Abi> / V::size()>
    split(const simd_mask<typename V::simd_type::value_type, Abi>&) noexcept;

template<size_t N, class T, class A>
  array<resize_simd<simd_size_v<T, A> / N, simd<T, A>>, N>
    split_by(const simd<T, A>& x) noexcept;
template<size_t N, class T, class A>
  array<resize_simd<simd_size_v<T, A> / N, simd_mask<T, A>>, N>
    split_by(const simd_mask<T, A>& x) noexcept;

template<class T, class... Abis>
  simd<T, simd_abi::deduce_t<T, (simd_size_v<T, Abis> + ...)>>
    concat(const simd<T, Abis>&...) noexcept;
template<class T, class... Abis>
  simd_mask<T, simd_abi::deduce_t<T, (simd_size_v<T, Abis> + ...)>>
    concat(const simd_mask<T, Abis>&...) noexcept;

template<class T, class Abi, size_t N>
  resize_simd<simd_size_v<T, Abi> * N, simd<T, Abi>>
    concat(const array<simd<T, Abi>, N>& arr) noexcept;
template<class T, class Abi, size_t N>
  resize_simd<simd_size_v<T, Abi> * N, simd_mask<T, Abi>>
    concat(const array<simd_mask<T, Abi>, N>& arr) noexcept;

// 9.9.4, reductions
template <class T, class Abi> bool all_of(const simd_mask<T, Abi>&) noexcept;
template <class T, class Abi> bool any_of(const simd_mask<T, Abi>&) noexcept;
template <class T, class Abi> bool none_of(const simd_mask<T, Abi>&) noexcept;
template <class T, class Abi> bool some_of(const simd_mask<T, Abi>&) noexcept;
template <class T, class Abi> int popcount(const simd_mask<T, Abi>&) noexcept;
template <class T, class Abi> int find_first_set(const simd_mask<T, Abi>&);
template <class T, class Abi> int find_last_set(const simd_mask<T, Abi>&);

bool all_of(T) noexcept;
bool any_of(T) noexcept;
bool none_of(T) noexcept;
bool some_of(T) noexcept;
int popcount(T) noexcept;
int find_first_set(T);
int find_last_set(T);

// 9.5, Where expression class templates
template <class M, class T> class const_where_expression;
template <class M, class T> class where_expression;

// 9.9.5, Where functions
template <class T, class Abi>
  where_expression<simd_mask<T, Abi>, simd<T, Abi>>
    where(const typename simd<T, Abi>::mask_type&, simd<T, Abi>&) noexcept;

template <class T, class Abi>
  const_where_expression<simd_mask<T, Abi>, const simd<T, Abi>>
    where(const typename simd<T, Abi>::mask_type&, const simd<T, Abi>&) noexcept;

template <class T, class Abi>
  where_expression<simd_mask<T, Abi>, simd_mask<T, Abi>>
    where(const type_identity_t<simd_mask<T, Abi>>&, simd_mask<T, Abi>&) noexcept;

template <class T, class Abi>
  const_where_expression<simd_mask<T, Abi>, const simd_mask<T, Abi>>
    where(const type_identity_t<simd_mask<T, Abi>>&, const simd_mask<T, Abi>&) noexcept;

template <class T>
  where_expression<bool, T>
    where(see below k, T& d) noexcept;

template <class T>
  const_where_expression<bool, T>
    where(see below k, const T& d) noexcept;

// 9.7.4, Reductions
template <class T, class Abi, class BinaryOperation = plus<>>
  T reduce(const simd<T, Abi>&,
           BinaryOperation = {});
template <class M, class V, class BinaryOperation>
  typename V::value_type reduce(const const_where_expression<M, V>& x,
                                typename V::value_type neutral_element,
                                BinaryOperation binary_op);
template <class M, class V>
  typename V::value_type reduce(const const_where_expression<M, V>& x,
                                plus<> binary_op = {}) noexcept;
template <class M, class V>
  typename V::value_type reduce(const const_where_expression<M, V>& x,
                                multiplies<> binary_op) noexcept;
template <class M, class V>
  typename V::value_type reduce(const const_where_expression<M, V>& x,
                                bit_and<> binary_op) noexcept;
template <class M, class V>
  typename V::value_type reduce(const const_where_expression<M, V>& x,
                                bit_or<> binary_op) noexcept;
template <class M, class V>
  typename V::value_type reduce(const const_where_expression<M, V>& x,
                                bit_xor<> binary_op) noexcept;

template <class T, class Abi>
  T hmin(const simd<T, Abi>&) noexcept;
template <class M, class V>
  typename V::value_type hmin(const const_where_expression<M, V>&) noexcept;
template <class T, class Abi>
  T hmax(const simd<T, Abi>&) noexcept;
template <class M, class V>
  typename V::value_type hmax(const const_where_expression<M, V>&) noexcept;

// 9.7.6, Algorithms
template <class T, class Abi>
  simd<T, Abi>
    min(const simd<T, Abi>& a, const simd<T, Abi>& b) noexcept;
template <class T, class Abi>
  simd<T, Abi>
    max(const simd<T, Abi>& a, const simd<T, Abi>& b) noexcept;
template <class T, class Abi>
  pair<simd<T, Abi>, simd<T, Abi>>
    minmax(const simd<T, Abi>& a, const simd<T, Abi>& b) noexcept;
template <class T, class Abi>
  simd<T, Abi>
    clamp(const simd<T, Abi>& v,
          const simd<T, Abi>& lo,
          const simd<T, Abi>& hi);

// 9.5, Where expression class templates [simd.whereexpr]
template <class M, class T> class const_where_expression {
  const M mask; // exposition only
  T& data;      // exposition only
public:
  const_where_expression(const const_where_expression&) = delete;
  const_where_expression& operator=(const const_where_expression&) = delete;

  T operator-() const && noexcept;
  T operator+() const && noexcept;
  T operator~() const && noexcept;

  template <class U, class Flags> void copy_to(U* mem, Flags f) const &&;
};

template <class M, class T>
class where_expression : public const_where_expression<M, T> {
public:
  template <class U> void operator=(U&& x) noexcept;
  template <class U> void operator+=(U&& x) noexcept;
  template <class U> void operator-=(U&& x) noexcept;
  template <class U> void operator*=(U&& x) noexcept;
  template <class U> void operator/=(U&& x) noexcept;
  template <class U> void operator%=(U&& x) noexcept;
  template <class U> void operator&=(U&& x) noexcept;
  template <class U> void operator|=(U&& x) noexcept;
  template <class U> void operator^=(U&& x) noexcept;
  template <class U> void operator<<=(U&& x) noexcept;
  template <class U> void operator>>=(U&& x) noexcept;

  void operator++() && noexcept;
  void operator++(int) && noexcept;
  void operator--() && noexcept;
  void operator--(int) && noexcept;

  template <class U, class Flags> void copy_from(const U* mem, Flags) &&;
};

// 9.6.1, Class template simd overview [simd.class.overview]
template <class T, class Abi> class simd {
public:
  using value_type = T;
  using reference = see below;
  using mask_type = simd_mask<T, Abi>;
  using abi_type = Abi;

  static constexpr size_t size() noexcept;

  simd() noexcept = default;

  // 9.6.4, simd constructors
  template <class U> simd(U&& value) noexcept;
  template <class U> simd(const simd<U, simd_abi::fixed_size<size()>>&) noexcept;
  template <class G> explicit simd(G&& gen) noexcept;
  template <class U, class Flags> simd(const U* mem, Flags f);

  // 9.6.5, simd copy functions
  template <class U, class Flags> void copy_from(const U* mem, Flags f);
  template <class U, class Flags> void copy_to(U* mem, Flags f);

  // 9.6.6, simd subscript operators
  reference operator[](size_t);
  value_type operator[](size_t) const;

  // 9.6.7, simd unary operators
  simd& operator++() noexcept;
  simd operator++(int) noexcept;
  simd& operator--() noexcept;
  simd operator--(int) noexcept;
  mask_type operator!() const noexcept;
  simd operator~() const noexcept;
  simd operator+() const noexcept;
  simd operator-() const noexcept;

  // 9.7.1, simd binary operators
  friend simd operator+ (const simd&, const simd&) noexcept;
  friend simd operator- (const simd&, const simd&) noexcept;
  friend simd operator* (const simd&, const simd&) noexcept;
  friend simd operator/ (const simd&, const simd&) noexcept;
  friend simd operator% (const simd&, const simd&) noexcept;
  friend simd operator& (const simd&, const simd&) noexcept;
  friend simd operator| (const simd&, const simd&) noexcept;
  friend simd operator^ (const simd&, const simd&) noexcept;
  friend simd operator<<(const simd&, const simd&) noexcept;
  friend simd operator>>(const simd&, const simd&) noexcept;
  friend simd operator<<(const simd&, int) noexcept;
  friend simd operator>>(const simd&, int) noexcept;

  // 9.7.2, simd compound assignment
  friend simd& operator+= (simd&, const simd&) noexcept;
  friend simd& operator-= (simd&, const simd&) noexcept;
  friend simd& operator*= (simd&, const simd&) noexcept;
  friend simd& operator/= (simd&, const simd&) noexcept;
  friend simd& operator%= (simd&, const simd&) noexcept;
  friend simd& operator&= (simd&, const simd&) noexcept;
  friend simd& operator|= (simd&, const simd&) noexcept;
  friend simd& operator^= (simd&, const simd&) noexcept;
  friend simd& operator<<=(simd&, const simd&) noexcept;
  friend simd& operator>>=(simd&, const simd&) noexcept;
  friend simd& operator<<=(simd&, int) noexcept;
  friend simd& operator>>=(simd&, int) noexcept;

  // 9.7.3, simd compare operators
  friend mask_type operator==(const simd&, const simd&) noexcept;
  friend mask_type operator!=(const simd&, const simd&) noexcept;
  friend mask_type operator>=(const simd&, const simd&) noexcept;
  friend mask_type operator<=(const simd&, const simd&) noexcept;
  friend mask_type operator> (const simd&, const simd&) noexcept;
  friend mask_type operator< (const simd&, const simd&) noexcept;
};

// 9.7.7, Math library [simd.math]
template <class Abi> using scharv = simd<signed char, Abi>; // exposition only
template <class Abi> using shortv = simd<short, Abi>; // exposition only
template <class Abi> using intv = simd<int, Abi>; // exposition only
template <class Abi> using longv = simd<long int, Abi>; // exposition only
template <class Abi> using llongv = simd<long long int, Abi>; // exposition only
template <class Abi> using floatv = simd<float, Abi>; // exposition only
template <class Abi> using doublev = simd<double, Abi>; // exposition only
template <class Abi> using ldoublev = simd<long double, Abi>; // exposition only
template <class T, class V> using samesize = fixed_size_simd<T, V::size()>; // exposition only

template <class Abi> floatv<Abi> acos(floatv<Abi> x);
template <class Abi> doublev<Abi> acos(doublev<Abi> x);
template <class Abi> ldoublev<Abi> acos(ldoublev<Abi> x);

template <class Abi> floatv<Abi> asin(floatv<Abi> x);
template <class Abi> doublev<Abi> asin(doublev<Abi> x);
template <class Abi> ldoublev<Abi> asin(ldoublev<Abi> x);

template <class Abi> floatv<Abi> atan(floatv<Abi> x);
template <class Abi> doublev<Abi> atan(doublev<Abi> x);
template <class Abi> ldoublev<Abi> atan(ldoublev<Abi> x);

template <class Abi> floatv<Abi> atan2(floatv<Abi> y, floatv<Abi> x);
template <class Abi> doublev<Abi> atan2(doublev<Abi> y, doublev<Abi> x);
template <class Abi> ldoublev<Abi> atan2(ldoublev<Abi> y, ldoublev<Abi> x);

template <class Abi> floatv<Abi> cos(floatv<Abi> x);
template <class Abi> doublev<Abi> cos(doublev<Abi> x);
template <class Abi> ldoublev<Abi> cos(ldoublev<Abi> x);

template <class Abi> floatv<Abi> sin(floatv<Abi> x);
template <class Abi> doublev<Abi> sin(doublev<Abi> x);
template <class Abi> ldoublev<Abi> sin(ldoublev<Abi> x);

template <class Abi> floatv<Abi> tan(floatv<Abi> x);
template <class Abi> doublev<Abi> tan(doublev<Abi> x);
template <class Abi> ldoublev<Abi> tan(ldoublev<Abi> x);

template <class Abi> floatv<Abi> acosh(floatv<Abi> x);
template <class Abi> doublev<Abi> acosh(doublev<Abi> x);
template <class Abi> ldoublev<Abi> acosh(ldoublev<Abi> x);

template <class Abi> floatv<Abi> asinh(floatv<Abi> x);
template <class Abi> doublev<Abi> asinh(doublev<Abi> x);
template <class Abi> ldoublev<Abi> asinh(ldoublev<Abi> x);

template <class Abi> floatv<Abi> atanh(floatv<Abi> x);
template <class Abi> doublev<Abi> atanh(doublev<Abi> x);
template <class Abi> ldoublev<Abi> atanh(ldoublev<Abi> x);

template <class Abi> floatv<Abi> cosh(floatv<Abi> x);
template <class Abi> doublev<Abi> cosh(doublev<Abi> x);
template <class Abi> ldoublev<Abi> cosh(ldoublev<Abi> x);

template <class Abi> floatv<Abi> sinh(floatv<Abi> x);
template <class Abi> doublev<Abi> sinh(doublev<Abi> x);
template <class Abi> ldoublev<Abi> sinh(ldoublev<Abi> x);

template <class Abi> floatv<Abi> tanh(floatv<Abi> x);
template <class Abi> doublev<Abi> tanh(doublev<Abi> x);
template <class Abi> ldoublev<Abi> tanh(ldoublev<Abi> x);

template <class Abi> floatv<Abi> exp(floatv<Abi> x);
template <class Abi> doublev<Abi> exp(doublev<Abi> x);
template <class Abi> ldoublev<Abi> exp(ldoublev<Abi> x);

template <class Abi> floatv<Abi> exp2(floatv<Abi> x);
template <class Abi> doublev<Abi> exp2(doublev<Abi> x);
template <class Abi> ldoublev<Abi> exp2(ldoublev<Abi> x);

template <class Abi> floatv<Abi> expm1(floatv<Abi> x);
template <class Abi> doublev<Abi> expm1(doublev<Abi> x);
template <class Abi> ldoublev<Abi> expm1(ldoublev<Abi> x);

template <class Abi> floatv<Abi> frexp(floatv<Abi> value, samesize<int, floatv<Abi>>* exp);
template <class Abi> doublev<Abi> frexp(doublev<Abi> value, samesize<int, doublev<Abi>>* exp);
template <class Abi> ldoublev<Abi> frexp(ldoublev<Abi> value, samesize<int, ldoublev<Abi>>* exp);

template <class Abi> samesize<int, floatv<Abi>> ilogb(floatv<Abi> x);
template <class Abi> samesize<int, doublev<Abi>> ilogb(doublev<Abi> x);
template <class Abi> samesize<int, ldoublev<Abi>> ilogb(ldoublev<Abi> x);

template <class Abi> floatv<Abi> ldexp(floatv<Abi> x, samesize<int, floatv<Abi>> exp);
template <class Abi> doublev<Abi> ldexp(doublev<Abi> x, samesize<int, doublev<Abi>> exp);
template <class Abi> ldoublev<Abi> ldexp(ldoublev<Abi> x, samesize<int, ldoublev<Abi>> exp);

template <class Abi> floatv<Abi> log(floatv<Abi> x);
template <class Abi> doublev<Abi> log(doublev<Abi> x);
template <class Abi> ldoublev<Abi> log(ldoublev<Abi> x);

template <class Abi> floatv<Abi> log10(floatv<Abi> x);
template <class Abi> doublev<Abi> log10(doublev<Abi> x);
template <class Abi> ldoublev<Abi> log10(ldoublev<Abi> x);

template <class Abi> floatv<Abi> log1p(floatv<Abi> x);
template <class Abi> doublev<Abi> log1p(doublev<Abi> x);
template <class Abi> ldoublev<Abi> log1p(ldoublev<Abi> x);

template <class Abi> floatv<Abi> log2(floatv<Abi> x);
template <class Abi> doublev<Abi> log2(doublev<Abi> x);
template <class Abi> ldoublev<Abi> log2(ldoublev<Abi> x);

template <class Abi> floatv<Abi> logb(floatv<Abi> x);
template <class Abi> doublev<Abi> logb(doublev<Abi> x);
template <class Abi> ldoublev<Abi> logb(ldoublev<Abi> x);

template <class Abi> floatv<Abi> modf(floatv<Abi> value, floatv<Abi>* iptr);
template <class Abi> doublev<Abi> modf(doublev<Abi> value, doublev<Abi>* iptr);
template <class Abi> ldoublev<Abi> modf(ldoublev<Abi> value, ldoublev<Abi>* iptr);

template <class Abi> floatv<Abi> scalbn(floatv<Abi> x, samesize<int, floatv<Abi>> n);
template <class Abi> doublev<Abi> scalbn(doublev<Abi> x, samesize<int, doublev<Abi>> n);
template <class Abi> ldoublev<Abi> scalbn(ldoublev<Abi> x, samesize<int, ldoublev<Abi>> n);
template <class Abi> floatv<Abi> scalbln(floatv<Abi> x, samesize<long int, floatv<Abi>> n);
template <class Abi> doublev<Abi> scalbln(doublev<Abi> x, samesize<long int, doublev<Abi>> n);
template <class Abi> ldoublev<Abi> scalbln(ldoublev<Abi> x, samesize<long int, ldoublev<Abi>> n);

template <class Abi> floatv<Abi> cbrt(floatv<Abi> x);
template <class Abi> doublev<Abi> cbrt(doublev<Abi> x);
template <class Abi> ldoublev<Abi> cbrt(ldoublev<Abi> x);

template <class Abi> scharv<Abi> abs(scharv<Abi> j);
template <class Abi> shortv<Abi> abs(shortv<Abi> j);
template <class Abi> intv<Abi> abs(intv<Abi> j);
template <class Abi> longv<Abi> abs(longv<Abi> j);
template <class Abi> llongv<Abi> abs(llongv<Abi> j);
template <class Abi> floatv<Abi> abs(floatv<Abi> j);
template <class Abi> doublev<Abi> abs(doublev<Abi> j);
template <class Abi> ldoublev<Abi> abs(ldoublev<Abi> j);

template <class Abi> floatv<Abi> hypot(floatv<Abi> x, floatv<Abi> y);
template <class Abi> doublev<Abi> hypot(doublev<Abi> x, doublev<Abi> y);
template <class Abi> ldoublev<Abi> hypot(doublev<Abi> x, doublev<Abi> y);
template <class Abi> floatv<Abi> hypot(floatv<Abi> x, floatv<Abi> y, floatv<Abi> z);
template <class Abi> doublev<Abi> hypot(doublev<Abi> x, doublev<Abi> y, doublev<Abi> z);
template <class Abi> ldoublev<Abi> hypot(ldoublev<Abi> x, ldoublev<Abi> y, ldoublev<Abi> z);

template <class Abi> floatv<Abi> pow(floatv<Abi> x, floatv<Abi> y);
template <class Abi> doublev<Abi> pow(doublev<Abi> x, doublev<Abi> y);
template <class Abi> ldoublev<Abi> pow(ldoublev<Abi> x, ldoublev<Abi> y);

template <class Abi> floatv<Abi> sqrt(floatv<Abi> x);
template <class Abi> doublev<Abi> sqrt(doublev<Abi> x);
template <class Abi> ldoublev<Abi> sqrt(ldoublev<Abi> x);

template <class Abi> floatv<Abi> erf(floatv<Abi> x);
template <class Abi> doublev<Abi> erf(doublev<Abi> x);
template <class Abi> ldoublev<Abi> erf(ldoublev<Abi> x);
template <class Abi> floatv<Abi> erfc(floatv<Abi> x);
template <class Abi> doublev<Abi> erfc(doublev<Abi> x);
template <class Abi> ldoublev<Abi> erfc(ldoublev<Abi> x);

template <class Abi> floatv<Abi> lgamma(floatv<Abi> x);
template <class Abi> doublev<Abi> lgamma(doublev<Abi> x);
template <class Abi> ldoublev<Abi> lgamma(ldoublev<Abi> x);

template <class Abi> floatv<Abi> tgamma(floatv<Abi> x);
template <class Abi> doublev<Abi> tgamma(doublev<Abi> x);
template <class Abi> ldoublev<Abi> tgamma(ldoublev<Abi> x);

template <class Abi> floatv<Abi> ceil(floatv<Abi> x);
template <class Abi> doublev<Abi> ceil(doublev<Abi> x);
template <class Abi> ldoublev<Abi> ceil(ldoublev<Abi> x);

template <class Abi> floatv<Abi> floor(floatv<Abi> x);
template <class Abi> doublev<Abi> floor(doublev<Abi> x);
template <class Abi> ldoublev<Abi> floor(ldoublev<Abi> x);

template <class Abi> floatv<Abi> nearbyint(floatv<Abi> x);
template <class Abi> doublev<Abi> nearbyint(doublev<Abi> x);
template <class Abi> ldoublev<Abi> nearbyint(ldoublev<Abi> x);

template <class Abi> floatv<Abi> rint(floatv<Abi> x);
template <class Abi> doublev<Abi> rint(doublev<Abi> x);
template <class Abi> ldoublev<Abi> rint(ldoublev<Abi> x);

template <class Abi> samesize<long int, floatv<Abi>> lrint(floatv<Abi> x);
template <class Abi> samesize<long int, doublev<Abi>> lrint(doublev<Abi> x);
template <class Abi> samesize<long int, ldoublev<Abi>> lrint(ldoublev<Abi> x);
template <class Abi> samesize<long long int, floatv<Abi>> llrint(floatv<Abi> x);
template <class Abi> samesize<long long int, doublev<Abi>> llrint(doublev<Abi> x);
template <class Abi> samesize<long long int, ldoublev<Abi>> llrint(ldoublev<Abi> x);

template <class Abi> floatv<Abi> round(floatv<Abi> x);
template <class Abi> doublev<Abi> round(doublev<Abi> x);
template <class Abi> ldoublev<Abi> round(ldoublev<Abi> x);
template <class Abi> samesize<long int, floatv<Abi>> lround(floatv<Abi> x);
template <class Abi> samesize<long int, doublev<Abi>> lround(doublev<Abi> x);
template <class Abi> samesize<long int, ldoublev<Abi>> lround(ldoublev<Abi> x);
template <class Abi> samesize<long long int, floatv<Abi>> llround(floatv<Abi> x);
template <class Abi> samesize<long long int, doublev<Abi>> llround(doublev<Abi> x);
template <class Abi> samesize<long long int, ldoublev<Abi>> llround(ldoublev<Abi> x);

template <class Abi> floatv<Abi> trunc(floatv<Abi> x);
template <class Abi> doublev<Abi> trunc(doublev<Abi> x);
template <class Abi> ldoublev<Abi> trunc(ldoublev<Abi> x);

template <class Abi> floatv<Abi> fmod(floatv<Abi> x, floatv<Abi> y);
template <class Abi> doublev<Abi> fmod(doublev<Abi> x, doublev<Abi> y);
template <class Abi> ldoublev<Abi> fmod(ldoublev<Abi> x, ldoublev<Abi> y);

template <class Abi> floatv<Abi> remainder(floatv<Abi> x, floatv<Abi> y);
template <class Abi> doublev<Abi> remainder(doublev<Abi> x, doublev<Abi> y);
template <class Abi> ldoublev<Abi> remainder(ldoublev<Abi> x, ldoublev<Abi> y);

template <class Abi> floatv<Abi> remquo(floatv<Abi> x, floatv<Abi> y, samesize<int, floatv<Abi>>* quo);
template <class Abi> doublev<Abi> remquo(doublev<Abi> x, doublev<Abi> y, samesize<int, doublev<Abi>>* quo);
template <class Abi> ldoublev<Abi> remquo(ldoublev<Abi> x, ldoublev<Abi> y, samesize<int, ldoublev<Abi>>* quo);

template <class Abi> floatv<Abi> copysign(floatv<Abi> x, floatv<Abi> y);
template <class Abi> doublev<Abi> copysign(doublev<Abi> x, doublev<Abi> y);
template <class Abi> ldoublev<Abi> copysign(ldoublev<Abi> x, ldoublev<Abi> y);

template <class Abi> doublev<Abi> nan(const char* tagp);
template <class Abi> floatv<Abi> nanf(const char* tagp);
template <class Abi> ldoublev<Abi> nanl(const char* tagp);

template <class Abi> floatv<Abi> nextafter(floatv<Abi> x, floatv<Abi> y);
template <class Abi> doublev<Abi> nextafter(doublev<Abi> x, doublev<Abi> y);
template <class Abi> ldoublev<Abi> nextafter(ldoublev<Abi> x, ldoublev<Abi> y);

template <class Abi> floatv<Abi> nexttoward(floatv<Abi> x, ldoublev<Abi> y);
template <class Abi> doublev<Abi> nexttoward(doublev<Abi> x, ldoublev<Abi> y);
template <class Abi> ldoublev<Abi> nexttoward(ldoublev<Abi> x, ldoublev<Abi> y);

template <class Abi> floatv<Abi> fdim(floatv<Abi> x, floatv<Abi> y);
template <class Abi> doublev<Abi> fdim(doublev<Abi> x, doublev<Abi> y);
template <class Abi> ldoublev<Abi> fdim(ldoublev<Abi> x, ldoublev<Abi> y);

template <class Abi> floatv<Abi> fmax(floatv<Abi> x, floatv<Abi> y);
template <class Abi> doublev<Abi> fmax(doublev<Abi> x, doublev<Abi> y);
template <class Abi> ldoublev<Abi> fmax(ldoublev<Abi> x, ldoublev<Abi> y);

template <class Abi> floatv<Abi> fmin(floatv<Abi> x, floatv<Abi> y);
template <class Abi> doublev<Abi> fmin(doublev<Abi> x, doublev<Abi> y);
template <class Abi> ldoublev<Abi> fmin(ldoublev<Abi> x, ldoublev<Abi> y);

template <class Abi> floatv<Abi> fma(floatv<Abi> x, floatv<Abi> y, floatv<Abi> z);
template <class Abi> doublev<Abi> fma(doublev<Abi> x, doublev<Abi> y, doublev<Abi> z);
template <class Abi> ldoublev<Abi> fma(ldoublev<Abi> x, ldoublev<Abi> y, ldoublev<Abi> z);

template <class Abi> samesize<int, floatv<Abi>> fpclassify(floatv<Abi> x);
template <class Abi> samesize<int, doublev<Abi>> fpclassify(doublev<Abi> x);
template <class Abi> samesize<int, ldoublev<Abi>> fpclassify(ldoublev<Abi> x);

template <class Abi> simd_mask<float, Abi> isfinite(floatv<Abi> x);
template <class Abi> simd_mask<double, Abi> isfinite(doublev<Abi> x);
template <class Abi> simd_mask<long double, Abi> isfinite(ldoublev<Abi> x);

template <class Abi> simd_mask<float, Abi> isinf(floatv<Abi> x);
template <class Abi> simd_mask<double, Abi> isinf(doublev<Abi> x);
template <class Abi> simd_mask<long double, Abi> isinf(ldoublev<Abi> x);

template <class Abi> simd_mask<float, Abi> isnan(floatv<Abi> x);
template <class Abi> simd_mask<double, Abi> isnan(doublev<Abi> x);
template <class Abi> simd_mask<long double, Abi> isnan(ldoublev<Abi> x);

template <class Abi> simd_mask<float, Abi> isnormal(floatv<Abi> x);
template <class Abi> simd_mask<double, Abi> isnormal(doublev<Abi> x);
template <class Abi> simd_mask<long double, Abi> isnormal(ldoublev<Abi> x);

template <class Abi> simd_mask<float, Abi> signbit(floatv<Abi> x);
template <class Abi> simd_mask<double, Abi> signbit(doublev<Abi> x);
template <class Abi> simd_mask<long double, Abi> signbit(ldoublev<Abi> x);

template <class Abi> simd_mask<float, Abi> isgreater(floatv<Abi> x, floatv<Abi> y);
template <class Abi> simd_mask<double, Abi> isgreater(doublev<Abi> x, doublev<Abi> y);
template <class Abi> simd_mask<long double, Abi> isgreater(ldoublev<Abi> x, ldoublev<Abi> y);

template <class Abi> simd_mask<float, Abi> isgreaterequal(floatv<Abi> x, floatv<Abi> y);
template <class Abi> simd_mask<double, Abi> isgreaterequal(doublev<Abi> x, doublev<Abi> y);
template <class Abi> simd_mask<long double, Abi> isgreaterequal(ldoublev<Abi> x, ldoublev<Abi> y);

template <class Abi> simd_mask<float, Abi> isless(floatv<Abi> x, floatv<Abi> y);
template <class Abi> simd_mask<double, Abi> isless(doublev<Abi> x, doublev<Abi> y);
template <class Abi> simd_mask<long double, Abi> isless(ldoublev<Abi> x, ldoublev<Abi> y);

template <class Abi> simd_mask<float, Abi> islessequal(floatv<Abi> x, floatv<Abi> y);
template <class Abi> simd_mask<double, Abi> islessequal(doublev<Abi> x, doublev<Abi> y);
template <class Abi> simd_mask<long double, Abi> islessequal(ldoublev<Abi> x, ldoublev<Abi> y);

template <class Abi> simd_mask<float, Abi> islessgreater(floatv<Abi> x, floatv<Abi> y);
template <class Abi> simd_mask<double, Abi> islessgreater(doublev<Abi> x, doublev<Abi> y);
template <class Abi> simd_mask<long double, Abi> islessgreater(ldoublev<Abi> x, ldoublev<Abi> y);

template <class Abi> simd_mask<float, Abi> isunordered(floatv<Abi> x, floatv<Abi> y);
template <class Abi> simd_mask<double, Abi> isunordered(doublev<Abi> x, doublev<Abi> y);
template <class Abi> simd_mask<long double, Abi> isunordered(ldoublev<Abi> x, ldoublev<Abi> y);

template <class V> struct simd_div_t { V quot, rem; };
template <class Abi> simd_div_t<scharv<Abi>> div(scharv<Abi> numer, scharv<Abi> denom);
template <class Abi> simd_div_t<shortv<Abi>> div(shortv<Abi> numer, shortv<Abi> denom);
template <class Abi> simd_div_t<intv<Abi>> div(intv<Abi> numer, intv<Abi> denom);
template <class Abi> simd_div_t<longv<Abi>> div(longv<Abi> numer, longv<Abi> denom);
template <class Abi> simd_div_t<llongv<Abi>> div(llongv<Abi> numer, llongv<Abi> denom);

// 9.8.1, Class template simd_mask overview [simd.mask.overview]
template <class T, class Abi> class simd_mask {
public:
  using value_type = bool;
  using reference = see below;
  using simd_type = simd<T, Abi>;
  using abi_type = Abi;

  static constexpr size_t size() noexcept;

  simd_mask() noexcept = default;

  // 9.8.3, Constructors
  explicit simd_mask(value_type) noexcept;
  template <class U>
    simd_mask(const simd_mask<U, simd_abi::fixed_size<size()>>&) noexcept;
  template <class Flags> simd_mask(const value_type* mem, Flags);

  // 9.8.4, Copy functions
  template <class Flags> void copy_from(const value_type* mem, Flags);
  template <class Flags> void copy_to(value_type* mem, Flags) const;

  // 9.8.5, Subscript operators
  reference operator[](size_t);
  value_type operator[](size_t) const;

  // 9.8.6, Unary operators
  simd_mask operator!() const noexcept;

  // 9.9.1, Binary operators
  friend simd_mask operator&&(const simd_mask&, const simd_mask&) noexcept;
  friend simd_mask operator||(const simd_mask&, const simd_mask&) noexcept;
  friend simd_mask operator& (const simd_mask&, const simd_mask&) noexcept;
  friend simd_mask operator| (const simd_mask&, const simd_mask&) noexcept;
  friend simd_mask operator^ (const simd_mask&, const simd_mask&) noexcept;

  // 9.9.2, Compound assignment
  friend simd_mask& operator&=(simd_mask&, const simd_mask&) noexcept;
  friend simd_mask& operator|=(simd_mask&, const simd_mask&) noexcept;
  friend simd_mask& operator^=(simd_mask&, const simd_mask&) noexcept;

  // 9.9.3, Comparisons
  friend simd_mask operator==(const simd_mask&, const simd_mask&) noexcept;
  friend simd_mask operator!=(const simd_mask&, const simd_mask&) noexcept;
};

} // parallelism_v2
} // std::experimental

*/

#include <experimental/__config>
#include <algorithm>
#include <array>
#include <cstddef>
#include <functional>
#include <type_traits>
#include <__simd/abi/builtin.h>
#include <__simd/abi/scalar.h>

#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#  pragma GCC system_header
#endif

_LIBCPP_PUSH_MACROS
#include <__undef_macros>

_LIBCPP_BEGIN_NAMESPACE_EXPERIMENTAL_SIMD

#if _LIBCPP_STD_VER >= 17

// TODO: handle _LIBCPP_HAS_NO_VECTOR_EXTENSION

template <class _Storage, class _ValueType>
class __simd_reference {
  template <class, class>
  friend struct simd;

  template <class, class>
  friend struct simd_mask;

  _Storage& __s_;
  size_t __idx_;

  __simd_reference(_Storage& __s, size_t __idx) : __s_(__s), __idx_(__idx) {}

  __simd_reference(const __simd_reference&) = default;

  _ValueType __get() const { return __s_.__get(__idx_); }

  void __set(_ValueType __v) { __s_.__set(__idx_, __v); }

public:
  using value_type = _ValueType;

  __simd_reference() = delete;
  __simd_reference& operator=(const __simd_reference&) = delete;

  operator value_type() const { return __get(); }

  __simd_reference operator=(value_type __v) && {
    __set(__v);
    return *this;
  }

  __simd_reference operator++() && {
    __set(__get() + 1);
    return *this;
  }

  value_type operator++(int) && {
    auto __r = __get();
    __set(__get() + 1);
    return __r;
  }

  __simd_reference operator--() && {
    __set(__get() - 1);
    return *this;
  }

  value_type operator--(int) && {
    auto __r = __get();
    __set(__get() - 1);
    return __r;
  }

  __simd_reference operator+=(value_type __v) && {
    __set(__get() + __v);
    return *this;
  }

  __simd_reference operator-=(value_type __v) && {
    __set(__get() - __v);
    return *this;
  }

  __simd_reference operator*=(value_type __v) && {
    __set(__get() * __v);
    return *this;
  }

  __simd_reference operator/=(value_type __v) && {
    __set(__get() / __v);
    return *this;
  }

  __simd_reference operator%=(value_type __v) && {
    __set(__get() % __v);
    return *this;
  }

  __simd_reference operator>>=(value_type __v) && {
    __set(__get() >> __v);
    return *this;
  }

  __simd_reference operator<<=(value_type __v) && {
    __set(__get() << __v);
    return *this;
  }

  __simd_reference operator&=(value_type __v) && {
    __set(__get() & __v);
    return *this;
  }

  __simd_reference operator|=(value_type __v) && {
    __set(__get() | __v);
    return *this;
  }

  __simd_reference operator^=(value_type __v) && {
    __set(__get() ^ __v);
    return *this;
  }
};

template <class _To, class _From>
constexpr decltype(_To{std::declval<_From>()}, true) __is_non_narrowing_convertible_impl(_From) {
  return true;
}

template <class _To>
constexpr bool __is_non_narrowing_convertible_impl(...) {
  return false;
}

template <class _From, class _To>
constexpr bool __is_non_narrowing_arithmetic_convertible() {
  if constexpr (std::is_arithmetic_v<_To> && std::is_arithmetic_v<_From>)
    return __is_non_narrowing_convertible_impl<_To>(_From{});
  else
    return false;
}

template <class _Tp, class... _Args>
constexpr _Tp __variadic_sum(_Args... __args) {
  return (static_cast<_Tp>(__args) + ...);
}

template <class _Tp>
constexpr bool __is_vectorizable() {
  return std::is_arithmetic_v<_Tp> && !std::is_const_v<_Tp> && !std::is_volatile_v<_Tp> && !std::is_same_v<_Tp, bool>;
}

template <class _Tp, class _Up>
constexpr bool __can_broadcast() {
  return (std::is_arithmetic_v<_Up> && __is_non_narrowing_arithmetic_convertible<_Up, _Tp>()) ||
         (!std::is_arithmetic_v<_Up> && std::is_convertible_v<_Up, _Tp>) ||
         std::is_same_v<std::remove_const_t<_Up>, int> ||
         (std::is_same_v<std::remove_const_t<_Up>, unsigned int> && std::is_unsigned_v<_Tp>);
}

template <class _Tp, class _Generator, size_t... __indicies>
constexpr decltype(std::forward_as_tuple(std::declval<_Generator>()(std::integral_constant<size_t, __indicies>())...),
                   bool())
__can_generate(std::index_sequence<__indicies...>) {
  return !__variadic_sum<bool>(
      !__can_broadcast<_Tp, decltype(std::declval<_Generator>()(std::integral_constant<size_t, __indicies>()))>()...);
}

template <class _Tp, class _Generator>
bool __can_generate(...) {
  return false;
}

_LIBCPP_END_NAMESPACE_EXPERIMENTAL_SIMD

_LIBCPP_BEGIN_NAMESPACE_EXPERIMENTAL_SIMD_ABI

using scalar = __scalar;

template <class _Tp>
inline constexpr size_t max_fixed_size = 32;

#if _LIBCPP_SIMD_X86INTRIN
template <int _Np>
using fixed_size = __vec_ext<_Np>;
template <class _Tp>
using compatible = __vec_ext<16 / sizeof(_Tp)>;
template <class _Tp>
using native = __vec_ext<_LIBCPP_NATIVE_SIMD_WIDTH_IN_BYTES / sizeof(_Tp)>;

#elif _LIBCPP_SIMD_HAVE_NEON
// FIXED ME: fixed_size implementation for NEON
template <int _Np>
using fixed_size = __vec_ext<_Np>;
template <class _Tp>
using compatible = __neon<16 / sizeof(_Tp)>;
template <class _Tp>
using native = __neon<16 / sizeof(_Tp)>;

#elif _LIBCPP_SIMD_HAVE_PPC
// FIXED ME: fixed_size implementation for PPC
template <int _Np>
using fixed_size = __vec_ext<_Np>;
template <class _Tp>
using compatible = __ppc<16 / sizeof(_Tp)>;
template <class _Tp>
using native = __ppc<16 / sizeof(_Tp)>;

#else
template <int>
using fixed_size = scalar;
template <class>
using compatible = scalar;
template <class>
using native = scalar;
#endif

template <class _Tp, size_t _Np, class... Abis>
struct deduce {
  using type = fixed_size<_Np>;
};

template <class _Tp, size_t _Np, class... Abis>
using deduce_t = typename deduce<_Tp, _Np>::type;

_LIBCPP_END_NAMESPACE_EXPERIMENTAL_SIMD_ABI

_LIBCPP_BEGIN_NAMESPACE_EXPERIMENTAL_SIMD

template <class _Tp, class _Abi = simd_abi::compatible<_Tp>>
class simd;

template <class _Tp, class _Abi = simd_abi::compatible<_Tp>>
class simd_mask;

// TODO: alignment related optimizations

struct element_aligned_tag {};

struct vector_aligned_tag {
  template <class _Tp, class _Up = typename _Tp::value_type>
  static constexpr size_t __alignmenet = __next_pow_of_2(sizeof(_Up) * _Tp::size());
};

template <size_t>
struct overaligned_tag {};

inline constexpr element_aligned_tag element_aligned{};

inline constexpr vector_aligned_tag vector_aligned{};

template <size_t _Np>
inline constexpr overaligned_tag<_Np> overaligned{};

// traits [simd.traits]
template <class _Tp, class = void>
struct __is_abi_tag_impl : std::false_type {};

template <class _Tp>
struct __is_abi_tag_impl<_Tp, std::enable_if_t<_Tp::__is_abi_tag>> : std::bool_constant<_Tp::__is_abi_tag> {};

template <class _Tp>
struct is_abi_tag : __is_abi_tag_impl<_Tp> {};

template <class _Tp>
inline constexpr bool is_abi_tag_v = is_abi_tag<_Tp>::value;

template <class _Tp>
struct is_simd : std::false_type {};

template <class _Tp, class _Abi>
struct is_simd<simd<_Tp, _Abi>> : std::true_type {};

template <class _Tp>
inline constexpr bool is_simd_v = is_simd<_Tp>::value;

template <class _Tp>
struct is_simd_mask : std::false_type {};

template <class _Tp, class _Abi>
struct is_simd_mask<simd_mask<_Tp, _Abi>> : std::true_type {};

template <class _Tp>
inline constexpr bool is_simd_mask_v = is_simd_mask<_Tp>::value;

template <class _Tp>
struct is_simd_flag_type : std::false_type {};

template <>
struct is_simd_flag_type<element_aligned_tag> : std::true_type {};

template <>
struct is_simd_flag_type<vector_aligned_tag> : std::true_type {};

template <size_t _Align>
struct is_simd_flag_type<overaligned_tag<_Align>> : std::true_type {};

template <class _Tp>
inline constexpr bool is_simd_flag_type_v = is_simd_flag_type<_Tp>::value;

template <class _Tp, class _Abi, class = void>
struct __simd_size_impl {};

template <class _Tp, class _Abi>
struct __simd_size_impl<_Tp, _Abi, std::enable_if_t<__is_vectorizable<_Tp>() && is_abi_tag_v<_Abi>>>
    : std::integral_constant<size_t, _Abi::__simd_size> {};

template <class _Tp, class _Abi = simd_abi::compatible<_Tp>>
struct simd_size : __simd_size_impl<_Tp, _Abi> {};

template <class _Tp, class _Abi = simd_abi::compatible<_Tp>>
inline constexpr size_t simd_size_v = simd_size<_Tp, _Abi>::value;

template <class _Tp, class _Up, class = void>
struct __memory_alignment_impl {};

template <class _Tp, class _Up>
struct __memory_alignment_impl<_Tp, _Up,
                               std::enable_if_t<(is_simd_v<_Tp> && __is_vectorizable<_Up>()) ||
                                                (is_simd_mask_v<_Tp> && std::is_same_v<_Up, bool>)>>
    : std::integral_constant<size_t, vector_aligned_tag::__alignmenet<_Tp, _Up>> {};

template <class _Tp, class _Up = typename _Tp::value_type>
struct memory_alignment : __memory_alignment_impl<_Tp, _Up> {};

template <class _Tp, class _Up = typename _Tp::value_type>
inline constexpr size_t memory_alignment_v = memory_alignment<_Tp, _Up>::value;

template <class T, class = void>
struct __has_type_impl : std::false_type {};

template <class T>
struct __has_type_impl<T, std::void_t<typename T::type>> : std::true_type {};

template <class T>
struct __has_type : __has_type_impl<T> {};

template <class T>
inline constexpr bool __has_type_v = __has_type<T>::value;

template <class _Tp, class _Vp, class = void>
struct __rebind_simd_impl {};

template <class _Tp, class _Vp>
struct __rebind_simd_impl<
    _Tp, _Vp,
    std::enable_if_t< __is_vectorizable<_Tp>() && is_simd_v<_Vp> &&
                      __has_type_v<simd_abi::deduce<_Tp, simd_size_v<typename _Vp::value_type, typename _Vp::abi_type>,
                                                    typename _Vp::abi_type>> >> {
  using type = simd<_Tp, simd_abi::deduce_t<_Tp, simd_size_v<typename _Vp::value_type, typename _Vp::abi_type>,
                                            typename _Vp::abi_type>>;
};

template <class _Tp, class _Vp>
struct __rebind_simd_impl<
    _Tp, _Vp,
    std::enable_if_t< __is_vectorizable<_Tp>() && is_simd_mask_v<_Vp> &&
                      __has_type_v<simd_abi::deduce<_Tp, simd_size_v<typename _Vp::value_type, typename _Vp::abi_type>,
                                                    typename _Vp::abi_type>> >> {
  using type = simd_mask<_Tp, simd_abi::deduce_t<_Tp, simd_size_v<typename _Vp::value_type, typename _Vp::abi_type>,
                                                 typename _Vp::abi_type>>;
};

template <class _Tp, class _Vp>
struct rebind_simd : __rebind_simd_impl<_Tp, _Vp> {};

template <class _Tp, class _Vp>
using rebind_simd_t = typename rebind_simd<_Tp, _Vp>::type;

template <int _Np, class _Vp, class = void>
struct __resize_simd_impl {};

template <int _Np, class _Vp>
struct __resize_simd_impl<
    _Np, _Vp,
    std::enable_if_t< is_simd_v<_Vp> &&
                      __has_type_v<simd_abi::deduce<typename _Vp::value_type, _Np, typename _Vp::abi_type>> >> {
  using type =
      simd<typename _Vp::value_type, simd_abi::deduce_t<typename _Vp::value_type, _Np, typename _Vp::abi_type>>;
};

template <int _Np, class _Vp>
struct __resize_simd_impl<
    _Np, _Vp,
    std::enable_if_t< is_simd_mask_v<_Vp> &&
                      __has_type_v<simd_abi::deduce<typename _Vp::value_type, _Np, typename _Vp::abi_type>> >> {
  using type =
      simd_mask<typename _Vp::value_type, simd_abi::deduce_t<typename _Vp::value_type, _Np, typename _Vp::abi_type>>;
};

template <int _Np, class _Vp>
struct resize_simd : __resize_simd_impl<_Np, _Vp> {};

template <int _Np, class _Vp>
using resize_simd_t = typename resize_simd<_Np, _Vp>::type;

// class template simd [simd.class]
template <class _Tp>
using native_simd = simd<_Tp, simd_abi::native<_Tp>>;

template <class _Tp, int _Np>
using fixed_size_simd = simd<_Tp, simd_abi::fixed_size<_Np>>;

// class template simd_mask [simd.mask.class]
template <class _Tp>
using native_simd_mask = simd_mask<_Tp, simd_abi::native<_Tp>>;

template <class _Tp, int _Np>
using fixed_size_simd_mask = simd_mask<_Tp, simd_abi::fixed_size<_Np>>;

// casts [simd.casts]
// TODO: implement
template <class _Tp>
struct __static_simd_cast_traits {
  template <class _Up, class _Abi>
  static simd<_Tp, _Abi> __apply(const simd<_Up, _Abi>& __v);
};

template <class _Tp, class _NewAbi>
struct __static_simd_cast_traits<simd<_Tp, _NewAbi>> {
  template <class _Up, class _Abi>
  static std::enable_if_t<simd<_Up, _Abi>::size() == simd<_Tp, _NewAbi>::size(), simd<_Tp, _NewAbi>>
  __apply(const simd<_Up, _Abi>& __v);
};

template <class _Tp>
struct __simd_cast_traits {
  template <class _Up, class _Abi>
  static std::enable_if_t<__is_non_narrowing_arithmetic_convertible<_Up, _Tp>(), simd<_Tp, _Abi>>
  __apply(const simd<_Up, _Abi>& __v);
};

template <class _Tp, class _NewAbi>
struct __simd_cast_traits<simd<_Tp, _NewAbi>> {
  template <class _Up, class _Abi>
  static std::enable_if_t<__is_non_narrowing_arithmetic_convertible<_Up, _Tp>() &&
                              simd<_Up, _Abi>::size() == simd<_Tp, _NewAbi>::size(),
                          simd<_Tp, _NewAbi>>
  __apply(const simd<_Up, _Abi>& __v);
};

template <class _Tp, class _Up, class _Abi>
auto simd_cast(const simd<_Up, _Abi>& __v) -> decltype(__simd_cast_traits<_Tp>::__apply(__v)) {
  return __simd_cast_traits<_Tp>::__apply(__v);
}

template <class _Tp, class _Up, class _Abi>
auto static_simd_cast(const simd<_Up, _Abi>& __v) -> decltype(__static_simd_cast_traits<_Tp>::__apply(__v)) {
  return __static_simd_cast_traits<_Tp>::__apply(__v);
}

template <class _Tp, class _Abi>
fixed_size_simd<_Tp, simd_size_v<_Tp, _Abi>> to_fixed_size(const simd<_Tp, _Abi>& __v) noexcept{
  return static_cast<fixed_size_simd<_Tp,simd_size_v<_Tp,_Abi>>>(__v);
}

template <class _Tp, class _Abi>
fixed_size_simd_mask<_Tp, simd_size_v<_Tp, _Abi>> to_fixed_size(const simd_mask<_Tp, _Abi>& __m) noexcept{
  return static_cast<fixed_size_simd_mask<_Tp,simd_size_v<_Tp,_Abi>>>(__m);
}

template <class _Tp, size_t _Np, std::enable_if_t<_Np == simd_size_v<_Tp,simd_abi::native<_Tp>>>* =nullptr>
native_simd<_Tp> to_native(const fixed_size_simd<_Tp, _Np>& __v) noexcept{
  return static_cast<native_simd<_Tp>>(__v);
}

template <class _Tp, size_t _Np, std::enable_if_t<_Np != simd_size_v<_Tp,simd_abi::native<_Tp>>>* = nullptr>
auto to_native(const fixed_size_simd<_Tp, _Np>& __v) noexcept{
  return __v;
}

template <class _Tp, size_t _Np, std::enable_if_t<_Np == simd_size_v<_Tp,simd_abi::native<_Tp>>>* = nullptr>
native_simd_mask<_Tp> to_native(const fixed_size_simd_mask<_Tp, _Np>& __m) noexcept{
  return static_cast<native_simd_mask<_Tp>>(__m);
}

template <class _Tp, size_t _Np, std::enable_if_t<_Np != simd_size_v<_Tp,simd_abi::native<_Tp>>>* = nullptr>
auto to_native(const fixed_size_simd_mask<_Tp, _Np>& __m) noexcept{
  return __m;
}

template <class _Tp, size_t _Np, std::enable_if_t<_Np == simd_size_v<_Tp>>* = nullptr>
simd<_Tp> to_compatible(const fixed_size_simd<_Tp, _Np>& __v) noexcept{
  return static_cast<simd<_Tp>>(__v);
}

template <class _Tp, size_t _Np, std::enable_if_t<_Np != simd_size_v<_Tp>>* = nullptr>
auto to_compatible(const fixed_size_simd<_Tp, _Np>& __v) noexcept{
  return __v;
}

template <class _Tp, size_t _Np, std::enable_if_t<_Np == simd_size_v<_Tp>>* = nullptr>
simd_mask<_Tp> to_compatible(const fixed_size_simd_mask<_Tp, _Np>& __m) noexcept{
  return static_cast<simd_mask<_Tp>>(__m);
}

template <class _Tp, size_t _Np, std::enable_if_t<_Np != simd_size_v<_Tp>>* = nullptr>
auto to_compatible(const fixed_size_simd_mask<_Tp, _Np>& __m) noexcept{
  return __m;
}


template < size_t... __sizes,class _Tp ,class _Abi>
std::enable_if_t<((0 + ... + __sizes) == simd_size_v<_Tp,_Abi>),tuple<simd<_Tp, simd_abi::deduce_t<_Tp, __sizes>>...>>
split(const simd<_Tp, _Abi>& __v){
  if constexpr(sizeof...(__sizes) == 1){
      return make_tuple(__v);
  }else{
    auto temp = make_tuple(simd<_Tp, simd_abi::fixed_size<__sizes>>()...);
    size_t k = 0;
    __for_tuple(temp,[__v,&k](auto&& item)
    {
      size_t i=0;
      while( i < item.size() ){
      item[i] = __v[k];
      ++k;
      ++i;
      }
    });
    return temp;
  }
}

template <size_t... __sizes,class _Tp ,class _Abi>
std::enable_if_t<((0 + ... + __sizes) == simd_size_v<_Tp,_Abi>),tuple<simd_mask<_Tp, simd_abi::deduce_t<_Tp, __sizes>>...>>
split(const simd_mask<_Tp, _Abi>& __m){
  if constexpr(sizeof...(__sizes) == 1){
      return make_tuple(__m);
  }else{
    auto temp = make_tuple(simd_mask<_Tp, simd_abi::fixed_size<__sizes>>()...);
    size_t k = 0;
    __for_tuple(temp,[__m,&k](auto&& item)
    {
      size_t i=0;
      while( i < item.size() ){
      item[i] = __m[k];
      ++k;
      ++i;
      }
    });
    return temp;
  }
}

template <class _SimdType, class _Abi>
std::enable_if_t<( is_simd_v<_SimdType> && (simd_size<typename _SimdType::value_type, _Abi>::value % _SimdType::size() == 0) )
,array<_SimdType, simd_size_v<typename _SimdType::value_type, _Abi> / _SimdType::size()>>
split(const simd<typename _SimdType::value_type, _Abi>& __v){

  if constexpr(simd_size<typename _SimdType::value_type, _Abi>::value / _SimdType::size() == 1){
    auto temp = std::array<simd<typename _SimdType::value_type, _Abi>,1>{};
    for(size_t i = 0; i < temp[0].size(); ++i){
      temp[0][i] = __v[i];
    }
    return temp;
  }else{
    auto temp = std::array<_SimdType, simd_size_v<typename _SimdType::value_type, _Abi> / _SimdType::size() >{};
    size_t k = 0;
    for(size_t i = 0; i < temp.size(); ++i){
      for(size_t j = 0; j < temp[i].size(); ++j){
        temp[i][j] = __v[k];
        ++k;
      }
    }
    return temp;
  }
}

template <class _SimdMaskType, class _Abi>
std::enable_if_t<( is_simd_mask_v<_SimdMaskType> && (simd_size_v<typename _SimdMaskType::simd_type::value_type, _Abi> % _SimdMaskType::size() == 0) )
,array<_SimdMaskType, simd_size_v<typename _SimdMaskType::simd_type::value_type, _Abi> / _SimdMaskType::size()>>
split(const simd_mask<typename _SimdMaskType::simd_type::value_type, _Abi>& __m){

  if constexpr(simd_size_v<typename _SimdMaskType::simd_type::value_type, _Abi> / _SimdMaskType::size() == 1){
    auto temp = std::array<simd_mask<typename _SimdMaskType::simd_type::value_type, _Abi>,1>{};
    for(size_t i = 0; i < temp[0].size(); ++i){
      temp[0][i] = __m[i];
    }
    return temp;
  }else{
    auto temp = std::array<_SimdMaskType, simd_size_v<typename _SimdMaskType::simd_type::value_type, _Abi> / _SimdMaskType::size() >();
    size_t k = 0;
    for(size_t i = 0; i < temp.size(); ++i){
      for(size_t j = 0; j < temp[i].size(); ++j){
        temp[i][j] = __m[k];
        ++k;
      }
    }
    return temp;
  }
}

template <class _Tp, class... _Abis>
simd<_Tp, simd_abi::deduce_t<_Tp, (simd_size_v<_Tp, _Abis> + ...) >> concat(const simd<_Tp, _Abis>&... __v){
  auto temp = simd<_Tp, simd_abi::deduce_t<_Tp, (simd_size_v<_Tp, _Abis> + ...) >>();
  int k = 0;
  ([&](){
        for(size_t i = 0; i < __v.size(); ++i){
            temp[k] = __v[i];
            ++k;
        }
    }(),...);
  return temp;
}

template <class _Tp, class... _Abis>
simd_mask<_Tp, simd_abi::deduce_t<_Tp, (simd_size_v<_Tp, _Abis> + ...) >> concat(const simd_mask<_Tp, _Abis>&... __m){
  auto temp = simd_mask<_Tp, simd_abi::deduce_t<_Tp, (simd_size_v<_Tp, _Abis> + ...) >>();
  int k = 0;
  ([&](){
        for(size_t i = 0; i < __m.size(); ++i){
            temp[k] = __m[i];
            ++k;
        }
    }(),...);
  return temp;
}


// reductions [simd.mask.reductions]
template <class _Tp, class _Abi>
bool all_of(const simd_mask<_Tp, _Abi>& __m) noexcept {
  return __mask_traits<_Tp, _Abi>::__all_of(__m.__s_);
}

template <class _Tp, class _Abi>
bool any_of(const simd_mask<_Tp, _Abi>& __m) noexcept {
  return __mask_traits<_Tp, _Abi>::__any_of(__m.__s_);
}

template <class _Tp, class _Abi>
bool none_of(const simd_mask<_Tp, _Abi>& __m) noexcept {
  return __mask_traits<_Tp, _Abi>::__none_of(__m.__s_);
}

template <class _Tp, class _Abi>
bool some_of(const simd_mask<_Tp, _Abi>& __m) noexcept {
  return __mask_traits<_Tp, _Abi>::__some_of(__m.__s_);
}

template <class _Tp, class _Abi>
int popcount(const simd_mask<_Tp, _Abi>& __m) noexcept {
  return __mask_traits<_Tp, _Abi>::__popcount(__m.__s_);
}

template <class _Tp, class _Abi>
int find_first_set(const simd_mask<_Tp, _Abi>& __m) {
  return __mask_traits<_Tp, _Abi>::__find_first_set(__m.__s_);
}

template <class _Tp, class _Abi>
int find_last_set(const simd_mask<_Tp, _Abi>& __m) {
  return __mask_traits<_Tp, _Abi>::__find_last_set(__m.__s_);
}

bool all_of(bool __v) noexcept { return __v; }

bool any_of(bool __v) noexcept { return __v; }

bool none_of(bool __v) noexcept { return !__v; }

bool some_of(bool) noexcept { return false; }

int popcount(bool __v) noexcept { return __v; }

int find_first_set(bool) noexcept { return 0; }

int find_last_set(bool) noexcept { return 0; }

// masked assignment [simd.whereexpr]
template <class _MaskType, class _Tp>
class const_where_expression;

template <class _MaskType, class _Tp>
class where_expression;

// masked assignment [simd.mask.where]
template <class _Tp, class _Abi>
where_expression<simd_mask<_Tp, _Abi>, simd<_Tp, _Abi>> where(const typename simd<_Tp, _Abi>::mask_type& __m,
                                                              simd<_Tp, _Abi>& __s) noexcept {
  return {__m, __s};
}

template <class _Tp, class _Abi>
const_where_expression<simd_mask<_Tp, _Abi>, const simd<_Tp, _Abi>>
where(const typename simd<_Tp, _Abi>::mask_type& __m, const simd<_Tp, _Abi>& __s) noexcept {
  return {__m, const_cast<simd<_Tp, _Abi>&>(__s)};
}

template <class _Tp, class _Abi>
where_expression<simd_mask<_Tp, _Abi>, simd_mask<_Tp, _Abi>> where(const __identity_t<simd_mask<_Tp, _Abi>>& __m,
                                                                   simd_mask<_Tp, _Abi>& __s) noexcept {
  return {__m, __s};
}

template <class _Tp, class _Abi>
const_where_expression<simd_mask<_Tp, _Abi>, const simd_mask<_Tp, _Abi>>
where(const __identity_t<simd_mask<_Tp, _Abi>>& __m, const simd_mask<_Tp, _Abi>& __s) noexcept {
  return {__m, const_cast<simd<_Tp, _Abi>&>(__s)};
}

template <class _Tp> // TODO: add SFINAE check here
where_expression<bool, _Tp> where(bool __m, _Tp& __s) noexcept {
  return {__m, __s};
}

template <class _Tp> // TODO: add SFINAE check here
const_where_expression<bool, _Tp> where(bool __m, const _Tp& __s) noexcept {
  return {__m, const_cast<_Tp&>(__s)};
}

// reductions [simd.reductions]
template <class _Tp, class _Abi, class _BinaryOp = plus<>>
_Tp reduce(const simd<_Tp, _Abi>& __s, _BinaryOp __binary_op = {}) {
    return __simd_traits<_Tp, _Abi>::__reduce(__s.__s_, __binary_op);
}

template <class _MaskType, class _SimdType, class _BinaryOp>
typename _SimdType::value_type reduce(const const_where_expression<_MaskType, _SimdType>& __w,
                                      typename _SimdType::value_type __identity, _BinaryOp __binary_op){
  if (none_of(__w.__m_)) {
    return __identity;
  }
  else {
    _SimdType tmp;
    for (size_t __i = 0; __i < _SimdType::abi_type::__simd_size; ++__i)
      tmp.__s_.__data[__i] = __w.__m_.__s_.__data[__i] ? __w.__s_.__s_.__data[__i] : __identity;
    return reduce(tmp, __binary_op);
  }
}

template <class _MaskType, class _SimdType>
typename _SimdType::value_type reduce(const const_where_expression<_MaskType, _SimdType>& __w,
                                      plus<> __binary_op = {}) noexcept {
  return reduce(__w, 0, __binary_op);
};

template <class _MaskType, class _SimdType>
typename _SimdType::value_type reduce(const const_where_expression<_MaskType, _SimdType>& __w,
                                      multiplies<> __binary_op) noexcept {
  return reduce(__w, 1, __binary_op);
};

template <class _MaskType, class _SimdType>
typename _SimdType::value_type reduce(const const_where_expression<_MaskType, _SimdType>& __w,
                                      bit_and<> __binary_op) noexcept {
  return reduce(__w, ~typename _SimdType::value_type(), __binary_op);
};

template <class _MaskType, class _SimdType>
typename _SimdType::value_type reduce(const const_where_expression<_MaskType, _SimdType>& __w,
                                      bit_or<> __binary_op) noexcept {
  return reduce(__w, 0, __binary_op);
};

template <class _MaskType, class _SimdType>
typename _SimdType::value_type reduce(const const_where_expression<_MaskType, _SimdType>& __w,
                                      bit_xor<> __binary_op) noexcept {
  return reduce(__w, 0, __binary_op);
};

template <class _Tp, class _Abi>
_Tp hmin(const simd<_Tp, _Abi>& __s) noexcept {
  return __simd_traits<_Tp, _Abi>::__hmin(__s.__s_);
}

// TODO: implement
template <class _MaskType, class _SimdType>
typename _SimdType::value_type hmin(const const_where_expression<_MaskType, _SimdType>& __w){
  if (none_of(__w.__m_)) {
    return numeric_limits<typename _SimdType::value_type>::max();
  } else {
    typename _SimdType::value_type __min = numeric_limits<typename _SimdType::value_type>::max();
    for (size_t i=0; i < __w.__s_.size(); i++) {
      if ( __w.__m_[i] == true && __w.__s_[i] <= __min) {
        __min = __w.__s_[i];
      }
    }
    return __min;
  }
};


template <class _Tp, class _Abi>
_Tp hmax(const simd<_Tp, _Abi>& __s) noexcept {
  return __simd_traits<_Tp, _Abi>::__hmax(__s.__s_);
}

// TODO: implement
template <class _MaskType, class _SimdType>
typename _SimdType::value_type hmax(const const_where_expression<_MaskType, _SimdType>& __w){
  if (none_of(__w.__m_)) {
        return numeric_limits<typename _SimdType::value_type>::lowest();
  } else {
    typename _SimdType::value_type __max = numeric_limits<typename _SimdType::value_type>::lowest();
    for (size_t i=0; i < __w.__s_.size(); i++) {
      if ( __w.__m_[i] == true && __w.__s_[i] >= __max) {
        __max = __w.__s_[i];
      }
    }
    return __max;
  }
};

// algorithms [simd.alg]
template <class _Tp, class _Abi>
simd<_Tp, _Abi> min(const simd<_Tp, _Abi>& __a, const simd<_Tp, _Abi>& __b) noexcept {
  return __simd_traits<_Tp, _Abi>::__min(__a.__s_, __b.__s_);
}

template <class _Tp, class _Abi>
simd<_Tp, _Abi> max(const simd<_Tp, _Abi>& __a, const simd<_Tp, _Abi>& __b) noexcept {
  return __simd_traits<_Tp, _Abi>::__max(__a.__s_, __b.__s_);
}

template <class _Tp, class _Abi>
pair<simd<_Tp, _Abi>, simd<_Tp, _Abi>> minmax(const simd<_Tp, _Abi>& __a, const simd<_Tp, _Abi>& __b) noexcept {
  auto [__min, __max] = __simd_traits<_Tp, _Abi>::__minmax(__a.__s_, __b.__s_);
  return {__min, __max};
}

template <class _Tp, class _Abi>
simd<_Tp, _Abi> clamp(const simd<_Tp, _Abi>& __v, const simd<_Tp, _Abi>& __lo, const simd<_Tp, _Abi>& __hi) noexcept{
  return __simd_traits<_Tp, _Abi>::__clamp(__v.__s_, __lo.__s_, __hi.__s_);
}

// [simd.whereexpr]
template <class _MaskType, class _SimdType>
class const_where_expression {
  using _Impl = typename _SimdType::_Impl;

  //friend const_where_expression where<>(const _MaskType&, const _SimdType&) noexcept;
  //friend const_where_expression where<>(const __identity_t<_MaskType>&, const _SimdType&) noexcept;
  //friend const_where_expression where<>(bool, const _SimdType&) noexcept;

  template <class _Mp, class _Vp, class _BinaryOp>
  friend typename _Vp::value_type
  reduce(const const_where_expression<_Mp, _Vp>& __w,
         typename _Vp::value_type __identity, _BinaryOp __op);

  template <class _Mp, class _Vp>
  friend typename _Vp::value_type
  hmin(const const_where_expression<_Mp, _Vp>& __w);

  template <class _Mp, class _Vp>
  friend typename _Vp::value_type
  hmax(const const_where_expression<_Mp, _Vp>& __w);

protected:
  const _MaskType __m_;
  _SimdType& __s_;

public:
  const_where_expression(const const_where_expression&) = delete;
  const_where_expression& operator=(const const_where_expression&) = delete;
  const_where_expression(const _MaskType& __m, const _SimdType& s)
    : __m_(__m), __s_(const_cast<_SimdType&>(s)) {}

  _SimdType operator-() const && noexcept { return _Impl::__masked_unary_minus(__s_.__s_, __m_.__s_); }
  _SimdType operator+() const && noexcept { return __s_; }
  _SimdType operator~() const && noexcept { return __m_ ? ~__s_ : __s_; }

  template <class _Tp, class _Flags>
  void copy_to(_Tp* __mem, _Flags) const && {
     _Impl::__masked_store(__s_.__s_, __m_.__s_, __mem/*_Flags::template _S_apply<_V>(__mem)*/);
  }
};

template <class _SimdType>
class const_where_expression<bool, _SimdType> {
  //friend const_where_expression where<>(const _MaskType&, const _SimdType&) noexcept;
  //friend const_where_expression where<>(const __identity_t<_MaskType>&, const _SimdType&) noexcept;
  //friend const_where_expression where<>(bool, const _SimdType&) noexcept;

  template <class _Mp, class _Vp, class _BinaryOp>
  friend typename _Vp::value_type
  reduce(const const_where_expression<_Mp, _Vp>& __w,
         typename _Vp::value_type __identity, _BinaryOp __op);

  template <class _Mp, class _Vp>
  friend typename _Vp::value_type
  hmin(const const_where_expression<_Mp, _Vp>& __w);

  template <class _Mp, class _Vp>
  friend typename _Vp::value_type
  hmax(const const_where_expression<_Mp, _Vp>& __w);

protected:
  const bool __m_;
  _SimdType& __s_;

public:
  const_where_expression(const const_where_expression&) = delete;
  const_where_expression& operator=(const const_where_expression&) = delete;
  const_where_expression(const bool __m, const _SimdType& s)
    : __m_(__m), __s_(const_cast<_SimdType&>(s)) {}

  _SimdType operator-() const && noexcept { return __m_ ? -__s_ : __s_; }
  _SimdType operator+() const && noexcept { return __s_; }
  _SimdType operator~() const && noexcept { return __m_ ? !__s_ : __s_; }

  template <class _Tp, class _Flags>
  void copy_to(_Tp* __mem, _Flags) const && {
    if(__m_)__mem[0] = __m_ ? __s_ : __mem[0];
  };
};


template <class _MaskType, class _SimdType>
class where_expression : public const_where_expression<_MaskType, _SimdType> {
  using _Impl = typename _SimdType::_Impl;

  using const_where_expression<_MaskType, _SimdType>::__m_;
  using const_where_expression<_MaskType, _SimdType>::__s_;

  //friend where_expression where<>(const _MaskType&, _SimdType&) noexcept;
  //friend where_expression where<>(const __identity_t<_MaskType>&, _SimdType&) noexcept;
  //friend where_expression where<>(bool, _SimdType&) noexcept;
  template <class _Tp>
  typename _SimdType::value_type __to_value_type(_Tp&& __v) const {
    return static_cast<typename _SimdType::value_type>(std::forward<_Tp>(__v));
  }

public:
  where_expression(const _MaskType& __m, _SimdType& s)
    : const_where_expression<_MaskType, _SimdType>(__m, s){}

  template <class _Tp>
  void operator=(_Tp&& __v) && noexcept {
    _Impl::__masked_assign(__s_.__s_, __m_.__s_, __to_value_type(std::forward<_Tp>(__v)));
  }
#define _LIBCXX_SIMD_MASK_OP_(__op,__name)              \
  template <class _Tp>                                  \
    void operator __op##=(_Tp&& __v) && noexcept {      \
      _Impl::__masked##__name(__s_.__s_, __m_.__s_,     \
        __to_value_type(std::forward<_Tp>(__v)));       \
    }
  _LIBCXX_SIMD_MASK_OP_(+, _plus)
  _LIBCXX_SIMD_MASK_OP_(-, _minus)
  _LIBCXX_SIMD_MASK_OP_(*, _multiplues)
  _LIBCXX_SIMD_MASK_OP_(/, _divides)
  _LIBCXX_SIMD_MASK_OP_(%, _modulus)
  _LIBCXX_SIMD_MASK_OP_(&, _bit_and)
  _LIBCXX_SIMD_MASK_OP_(|, _bit_or)
  _LIBCXX_SIMD_MASK_OP_(^, _bit_xor)
  _LIBCXX_SIMD_MASK_OP_(<<, _shift_left)
  _LIBCXX_SIMD_MASK_OP_(>>, _shift_right)
#undef _LIBCXX_SIMD_MASK_OP_

  void operator++() && noexcept {
     _Impl::__masked_incre(__s_.__s_, __m_.__s_);
  }
  void operator++(int) && noexcept {
    simd __r = *this;
    _Impl::__masked_incre(__s_.__s_, __m_.__s_);
    return __r;

  }
  void operator--() && noexcept {
     _Impl::__masked_decre(__s_.__s_, __m_.__s_);
  }
  void operator--(int) && noexcept {
    simd __r = *this;
    _Impl::__masked_decre(__s_.__s_, __m_.__s_);
    return __r;
  }

  template <class _Tp, class _Flags>
  void copy_from(const _Tp* __mem, _Flags) && {
     _Impl:: __masked_load(__s_.__s_, __m_.__s_, __mem/*_Flags::template _S_apply<_V>(__mem)*/);
  }
};

template <class _SimdType>
class where_expression<bool, _SimdType> : public const_where_expression<bool, _SimdType> {
  using const_where_expression<bool, _SimdType>::__m_;
  using const_where_expression<bool, _SimdType>::__s_;

  //friend where_expression where<>(const _MaskType&, _SimdType&) noexcept;
  //friend where_expression where<>(const type_identity_t<_MaskType>&, _SimdType&) noexcept;
  //friend where_expression where<>(bool, _SimdType&) noexcept;

public:
  where_expression(const bool __m, _SimdType& s)
    : const_where_expression<bool, _SimdType>(__m, s){}

  template <class _Tp>
  void operator=(_Tp&& __v) && noexcept {
    __s_ = __m_ ? __v : __s_;
  }
#define _LIBCXX_SIMD_MASK_OP_(__op,__name)            \
  template <class _Tp>                                \
    void operator __op##=(_Tp&& __v) && noexcept {    \
      __s_ = __m_ ? __s_ __op __v : __s_;             \
    }
  _LIBCXX_SIMD_MASK_OP_(+, _plus)
  _LIBCXX_SIMD_MASK_OP_(-, _minus)
  _LIBCXX_SIMD_MASK_OP_(*, _multiplues)
  _LIBCXX_SIMD_MASK_OP_(/, _divides)
  _LIBCXX_SIMD_MASK_OP_(%, _modulus)
  _LIBCXX_SIMD_MASK_OP_(&, _bit_and)
  _LIBCXX_SIMD_MASK_OP_(|, _bit_or)
  _LIBCXX_SIMD_MASK_OP_(^, _bit_xor)
  _LIBCXX_SIMD_MASK_OP_(<<, _shift_left)
  _LIBCXX_SIMD_MASK_OP_(>>, _shift_right)
#undef _LIBCXX_SIMD_MASK_OP_

  void operator++() && noexcept {
    if(__m_) __s_++;
  }
  void operator++(int) && noexcept {
    if(__m_) ++__s_;
  }
  void operator--() && noexcept {
    if(__m_) __s_--;
  }
  void operator--(int) && noexcept {
    if(__m_) --__s_;
  }

  template <class _Tp, class _Flags>
  void copy_from(const _Tp* __mem, _Flags) && {
    __s_ = __m_ ? __mem[0] : __s_;
  }
};


// [simd.class]
template <class _Tp, class _Abi>
class simd {
  using _Impl = __simd_traits<_Tp, _Abi>;
  using _Storage = typename _Impl::_Simd;

  _Storage __s_;

  simd(_Storage __s) : __s_(__s) {}

  friend class simd_mask<_Tp, _Abi>;

  template <class _MaskType, class _SimdType>
  friend class const_where_expression;

  template <class _MaskType, class _SimdType>
  friend class where_expression;

  friend simd min<>(const simd&, const simd&) noexcept;
  friend simd max<>(const simd&, const simd&) noexcept;
  friend std::pair<simd, simd> minmax<>(const simd&, const simd&) noexcept;
  friend simd clamp<>(const simd&, const simd&, const simd&) noexcept;
  friend _Tp hmin<>(const simd&) noexcept;
  friend _Tp hmax<>(const simd&) noexcept;

  template <class __Tp, class __Abi, class _BinaryOp>
  friend __Tp reduce(const simd<__Tp, __Abi>&, _BinaryOp);

  template <class _Mp, class _Vp, class _BinaryOp>
  friend typename _Vp::value_type
  reduce(const const_where_expression<_Mp, _Vp>& __w,
         typename _Vp::value_type __identity, _BinaryOp __op);

  template <class _Mp, class _Vp>
  friend typename _Vp::value_type
  hmin(const const_where_expression<_Mp, _Vp>& __w);

  template <class _Mp, class _Vp>
  friend typename _Vp::value_type
  hmax(const const_where_expression<_Mp, _Vp>& __w);

public:
  using value_type = _Tp;
  using reference = __simd_reference<_Storage, value_type>;
  using mask_type = simd_mask<_Tp, _Abi>;
  using abi_type = _Abi;

  simd() = default;
  simd(const simd&) = default;
  simd& operator=(const simd&) = default;

  static constexpr size_t size() noexcept { return simd_size_v<value_type, abi_type>; }

  // implicit broadcast constructor
  template <class _Up, std::enable_if_t<__can_broadcast<value_type, _Up>(), int> = 0>
  simd(_Up&& __v) : __s_(_Impl::__broadcast(static_cast<value_type>(__v))) {}

  // implicit type conversion constructor
  template <class _Up, class = std::enable_if_t<std::is_same_v<abi_type, simd_abi::fixed_size<size()>> &&
                                                __is_non_narrowing_arithmetic_convertible<_Up, value_type>()>>
  simd(const simd<_Up, simd_abi::fixed_size<size()>>& __v)
      : simd(static_cast<std::array<_Up, size()>>(__v).data(), vector_aligned) {}

  // generator constructor
  template <class _Generator,
            std::enable_if_t<__can_generate<value_type, _Generator>(std::make_index_sequence<size()>()), int> = 0>
  explicit simd(_Generator&& __g) : __s_(_Impl::__generate(std::forward<_Generator>(__g))) {}

  // load constructor
  template <class _Up, class _Flags, class = std::enable_if_t<__is_vectorizable<_Up>() && is_simd_flag_type_v<_Flags>>>
  simd(const _Up* __mem, _Flags __f) : __s_(_Impl::__load(__mem, __f)) {}

  // loads [simd.load]
  template <class _Up, class _Flags>
  std::enable_if_t<__is_vectorizable<_Up>() && is_simd_flag_type_v<_Flags>> copy_from(const _Up* __mem, _Flags __f) {
    __s_ = _Impl::__load(__mem, __f);
  }

  // stores [simd.store]
  template <class _Up, class _Flags>
  std::enable_if_t<__is_vectorizable<_Up>() && is_simd_flag_type_v<_Flags>> copy_to(_Up* __mem, _Flags __f) const {
    _Impl::__store(__s_, __mem, __f);
  }

  // scalar access [simd.subscr]
  reference operator[](size_t __i) { return reference(__s_, __i); }

  value_type operator[](size_t __i) const { return __s_.__get(__i); }

  // unary operators [simd.unary]
  simd& operator++() noexcept {
    _Impl::__increment(__s_);
    return *this;
  }

  simd operator++(int) noexcept {
    simd __r = *this;
    _Impl::__increment(__s_);
    return __r;
  }

  simd& operator--() noexcept {
    _Impl::__decrement(__s_);
    return *this;
  }

  simd operator--(int) noexcept {
    simd __r = *this;
    _Impl::__decrement(__s_);
    return __r;
  }

  mask_type operator!() const noexcept { return _Impl::__negate(__s_); }

  simd operator~() const noexcept { return _Impl::__bitwise_not(__s_); }

  simd operator+() const noexcept { return *this; }

  simd operator-() const noexcept { return _Impl::__unary_minus(__s_); }

  // binary operators [simd.binary]
  friend simd operator+(const simd& __lhs, const simd& __rhs) noexcept { return _Impl::__plus(__lhs.__s_, __rhs.__s_); }

  friend simd operator-(const simd& __lhs, const simd& __rhs) noexcept {
    return _Impl::__minus(__lhs.__s_, __rhs.__s_);
  }

  friend simd operator*(const simd& __lhs, const simd& __rhs) noexcept {
    return _Impl::__multiplies(__lhs.__s_, __rhs.__s_);
  }

  friend simd operator/(const simd& __lhs, const simd& __rhs) noexcept {
    return _Impl::__divides(__lhs.__s_, __rhs.__s_);
  }

  friend simd operator%(const simd& __lhs, const simd& __rhs) noexcept {
    return _Impl::__modulus(__lhs.__s_, __rhs.__s_);
  }

  friend simd operator&(const simd& __lhs, const simd& __rhs) noexcept {
    return _Impl::__bitwise_and(__lhs.__s_, __rhs.__s_);
  }

  friend simd operator|(const simd& __lhs, const simd& __rhs) noexcept {
    return _Impl::__bitwise_or(__lhs.__s_, __rhs.__s_);
  }

  friend simd operator^(const simd& __lhs, const simd& __rhs) noexcept {
    return _Impl::__bitwise_xor(__lhs.__s_, __rhs.__s_);
  }

  friend simd operator<<(const simd& __lhs, const simd& __rhs) noexcept {
    return _Impl::__shift_left(__lhs.__s_, __rhs.__s_);
  }

  friend simd operator>>(const simd& __lhs, const simd& __rhs) noexcept {
    return _Impl::__shift_right(__lhs.__s_, __rhs.__s_);
  }

  friend simd operator<<(const simd& __lhs, int __rhs) noexcept { return _Impl::__shift_left(__lhs.__s_, __rhs); }

  friend simd operator>>(const simd& __lhs, int __rhs) noexcept { return _Impl::__shift_right(__lhs.__s_, __rhs); }

  // compound assignment [simd.cassign]
  friend simd& operator+=(simd& __lhs, const simd& __rhs) noexcept { return __lhs = __lhs + __rhs; }

  friend simd& operator-=(simd& __lhs, const simd& __rhs) noexcept { return __lhs = __lhs - __rhs; }

  friend simd& operator*=(simd& __lhs, const simd& __rhs) noexcept { return __lhs = __lhs * __rhs; }

  friend simd& operator/=(simd& __lhs, const simd& __rhs) noexcept { return __lhs = __lhs / __rhs; }

  friend simd& operator%=(simd& __lhs, const simd& __rhs) noexcept { return __lhs = __lhs % __rhs; }

  friend simd& operator&=(simd& __lhs, const simd& __rhs) noexcept { return __lhs = __lhs & __rhs; }

  friend simd& operator|=(simd& __lhs, const simd& __rhs) noexcept { return __lhs = __lhs | __rhs; }

  friend simd& operator^=(simd& __lhs, const simd& __rhs) noexcept { return __lhs = __lhs ^ __rhs; }

  friend simd& operator<<=(simd& __lhs, const simd& __rhs) noexcept { return __lhs = __lhs << __rhs; }

  friend simd& operator>>=(simd& __lhs, const simd& __rhs) noexcept { return __lhs = __lhs >> __rhs; }

  friend simd& operator<<=(simd& __lhs, int __rhs) noexcept { return __lhs = __lhs << __rhs; }

  friend simd& operator>>=(simd& __lhs, int __rhs) noexcept { return __lhs = __lhs >> __rhs; }

  // compares [simd.comparison]
  friend mask_type operator==(const simd& __lhs, const simd& __rhs) noexcept {
    return _Impl::__equal_to(__lhs.__s_, __rhs.__s_);
  }

  friend mask_type operator!=(const simd& __lhs, const simd& __rhs) noexcept {
    return _Impl::__not_equal_to(__lhs.__s_, __rhs.__s_);
  }

  friend mask_type operator>=(const simd& __lhs, const simd& __rhs) noexcept {
    return _Impl::__less_equal(__rhs.__s_, __lhs.__s_);
  }

  friend mask_type operator<=(const simd& __lhs, const simd& __rhs) noexcept {
    return _Impl::__less_equal(__lhs.__s_, __rhs.__s_);
  }

  friend mask_type operator>(const simd& __lhs, const simd& __rhs) noexcept {
    return _Impl::__less(__rhs.__s_, __lhs.__s_);
  }

  friend mask_type operator<(const simd& __lhs, const simd& __rhs) noexcept {
    return _Impl::__less(__lhs.__s_, __rhs.__s_);
  }
};

// [simd.mask.class]
template <class _Tp, class _Abi>
class simd_mask {
  using _Impl = __mask_traits<_Tp, _Abi>;
  using _Storage = typename _Impl::_Mask;

  _Storage __s_;

  simd_mask(_Storage __s) : __s_(__s) {}

  friend class simd<_Tp, _Abi>;

  template <class _MaskType, class _SimdType>
  friend class const_where_expression;

  template <class _MaskType, class _SimdType>
  friend class where_expression;

  template <class __Tp, class __Abi, class _BinaryOp>
  friend __Tp reduce(const simd<__Tp, __Abi>&, _BinaryOp);

  template <class _Mp, class _Vp, class _BinaryOp>
  friend typename _Vp::value_type
  reduce(const const_where_expression<_Mp, _Vp>& __w,
         typename _Vp::value_type __identity, _BinaryOp __op);

  friend bool all_of<>(const simd_mask&) noexcept;
  friend bool any_of<>(const simd_mask&) noexcept;
  friend bool none_of<>(const simd_mask&) noexcept;
  friend bool some_of<>(const simd_mask&) noexcept;
  friend int popcount<>(const simd_mask&) noexcept;
  friend int find_first_set<>(const simd_mask&);
  friend int find_last_set<>(const simd_mask&);

public:
  using value_type = bool;
  using reference = __simd_reference<_Storage, value_type>;
  using simd_type = simd<_Tp, _Abi>;
  using abi_type = _Abi;

  static constexpr size_t size() noexcept { return simd_type::size(); }

  simd_mask() = default;

  // broadcast constructor
  explicit simd_mask(value_type __v) noexcept : __s_(_Impl::__broadcast(static_cast<value_type>(__v))) {}

  // implicit type conversion constructor
  template <class _Up, class = std::enable_if_t<std::is_same_v<abi_type, simd_abi::fixed_size<size()>> &&
                                                __is_non_narrowing_arithmetic_convertible<_Up, value_type>()>>
  simd_mask(const simd_mask<_Up, simd_abi::fixed_size<size()>>& __v) noexcept
      : simd_mask(static_cast<std::array<_Up, size()>>(__v).data(), vector_aligned) {}

  // load constructor
  template <class _Flags, class = std::enable_if_t<is_simd_flag_type_v<_Flags>>>
  simd_mask(const value_type* __mem, _Flags __f) : __s_(_Impl::__load(__mem, __f)) {}

  // loads [simd.mask.copy]
  template <class _Flags>
  std::enable_if_t<is_simd_flag_type_v<_Flags>> copy_from(const value_type* __mem, _Flags __f) {
    __s_ = _Impl::__load(__mem, __f);
  }

  template <class _Flags>
  std::enable_if_t<is_simd_flag_type_v<_Flags>> copy_to(value_type* __mem, _Flags __f) const {
    _Impl::__store(__s_, __mem, __f);
  }

  // scalar access [simd.mask.subscr]
  reference operator[](size_t __i) { return reference(__s_, __i); }

  value_type operator[](size_t __i) const { return __s_.__get(__i); }

  // unary operators [simd.mask.unary]
  simd_mask operator!() const noexcept { return _Impl::__negate(__s_); }

  // simd_mask binary operators [simd.mask.binary]
  friend simd_mask operator&&(const simd_mask& __lhs, const simd_mask& __rhs) noexcept {
    return _Impl::__logical_and(__lhs.__s_, __rhs.__s_);
  }

  friend simd_mask operator||(const simd_mask& __lhs, const simd_mask& __rhs) noexcept {
    return _Impl::__logical_or(__lhs.__s_, __rhs.__s_);
  }

  friend simd_mask operator&(const simd_mask& __lhs, const simd_mask& __rhs) noexcept {
    return _Impl::__bitwise_and(__lhs.__s_, __rhs.__s_);
  }

  friend simd_mask operator|(const simd_mask& __lhs, const simd_mask& __rhs) noexcept {
    return _Impl::__bitwise_or(__lhs.__s_, __rhs.__s_);
  }

  friend simd_mask operator^(const simd_mask& __lhs, const simd_mask& __rhs) noexcept {
    return _Impl::__bitwise_xor(__lhs.__s_, __rhs.__s_);
  }

  // simd_mask compound assignment [simd.mask.cassign]
  friend simd_mask& operator&=(simd_mask& __lhs, const simd_mask& __rhs) noexcept { return __lhs = __lhs & __rhs; }

  friend simd_mask& operator|=(simd_mask& __lhs, const simd_mask& __rhs) noexcept { return __lhs = __lhs | __rhs; }

  friend simd_mask& operator^=(simd_mask& __lhs, const simd_mask& __rhs) noexcept { return __lhs = __lhs ^ __rhs; }

  // simd_mask compares [simd.mask.comparison]
  friend simd_mask operator==(const simd_mask& __lhs, const simd_mask& __rhs) noexcept {
    return _Impl::__equal_to(__lhs.__s_, __rhs.__s_);
  }

  friend simd_mask operator!=(const simd_mask& __lhs, const simd_mask& __rhs) noexcept {
    return _Impl::__not_equal_to(__lhs.__s_, __rhs.__s_);
  }
};

#endif // _LIBCPP_STD_VER >= 17

_LIBCPP_END_NAMESPACE_EXPERIMENTAL_SIMD

_LIBCPP_POP_MACROS

#endif // _LIBCPP_EXPERIMENTAL_SIMD
